<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#a-simple-service-example-atomicnumberservice">A simple service example: <code>AtomicNumberService</code></a><ul>
<li><a href="#how-to-use-this-document">How to use this document</a></li>
<li><a href="#the-factorisation-model-for-services">The factorisation model for services</a></li>
<li><a href="#files">Files</a><ul>
<li><a href="#directory-structure">Directory structure</a></li>
</ul></li>
<li><a href="#the-service-provider-atomicnumber">The service provider: <code>AtomicNumber</code></a><ul>
<li><a href="#cmakelists.txt"><code>CMakeLists.txt</code></a></li>
<li><a href="#atomicnumber.h"><code>AtomicNumber.h</code></a></li>
<li><a href="#atomicnumber.cxx"><code>AtomicNumber.cxx</code></a></li>
<li><a href="#atomic_number_standard.fcl"><code>atomic_number_standard.fcl</code></a></li>
</ul></li>
<li><a href="#the-service-atomicnumberservice">The service: <code>AtomicNumberService</code></a><ul>
<li><a href="#atomicnumberservice.h">AtomicNumberService.h</a></li>
<li><a href="#atomicnumberservice_service.cc"><code>AtomicNumberService_service.cc</code></a></li>
</ul></li>
<li><a href="#tests">Tests</a><ul>
<li><a href="#cmakelists.txt-1">CMakeLists.txt</a></li>
<li><a href="#atomicnumber_test.cc">AtomicNumber_test.cc</a></li>
<li><a href="#boostedatomicnumber_test.cc">BoostedAtomicNumber_test.cc</a></li>
<li><a href="#validateatomicnumberconfiguration_test.cc">ValidateAtomicNumberConfiguration_test.cc</a></li>
<li><a href="#atomicnumbertest_module.cc">AtomicNumberTest_module.cc</a></li>
</ul></li>
<li><a href="#questions">Questions?</a></li>
</ul></li>
</ul>
</div>
<table>
<thead>
<tr class="header">
<th>Example name:</th>
<th>AtomicNumber</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Type:</td>
<td>LArSoft service and provider</td>
</tr>
<tr class="even">
<td>Author:</td>
<td>Gianluca Petrillo (petrillo@fnal.gov)</td>
</tr>
<tr class="odd">
<td>Created on:</td>
<td>April 13, 2016</td>
</tr>
</tbody>
</table>
<h1 id="a-simple-service-example-atomicnumberservice">A simple service example: <code>AtomicNumberService</code></h1>
<p>This example shows a complete service with a minimal interface.</p>
<p>Features of the service:</p>
<ul>
<li>the interface returns a single quantity: the atomic number of the active material in the TPC</li>
<li>reads the configuration from a FHiCL file</li>
<li>provides a “standard” FHiCL configuration</li>
</ul>
<p>Missing features that you need to go elsewhere if you need to implement:</p>
<ul>
<li>multiple implementation (for example, for different detectors)</li>
<li>reaction to framework events (new event, end of run, closing input file…)</li>
<li>integration test</li>
</ul>
<p>Technical choices:</p>
<ul>
<li>employs the service/provider factorization model</li>
<li>uses validation of the configuration</li>
<li>has four tests (three for the provider and one for the service)</li>
<li>it is fully documented via Doxygen interpreted comments</li>
</ul>
<h3 id="how-to-use-this-document">How to use this document</h3>
<p>This document is pretty long. You are encouraged to read it all, but you might understandably opt out of that. The document is organised in sections. We suggest that you read the section above to know what this example is about, and the (very terse) explanation of the model, and the beginning of the section of the provider header. These contain information about the design that can stimulate your own. Then, you can dig into the code and come back to the pertinent section when you have questions.</p>
<p>For every questions, answered or not here, you are strongly encouraged to contact the example’s author (contact information is at the top of this file).</p>
<p>And, if you want to have a bit more printer friendly format, know this text file is written in markdown format and you can convert it to something else with:</p>
<pre><code>pandoc -s -S --toc -o README.html README
pandoc -s -S --toc -o README.pdf README</code></pre>
<p>et cetera.</p>
<h2 id="the-factorisation-model-for-services">The factorisation model for services</h2>
<p>The factorisation model prescribes the code to be split in a functional part that is independent of the framework, and a framework interface.</p>
<p>In case of services, LArSoft calls the functional part a <em>service provider</em> (or just <em>provider</em>) and the interface a <em>art service</em> (sometimes just <em>service</em>).</p>
<p>A more extensive description of this model can be found in LArSoft wiki: <a href="https://cdcvs.fnal.gov/redmine/projects/larsoft/wiki/Writing_LArSoft_service" class="uri">https://cdcvs.fnal.gov/redmine/projects/larsoft/wiki/Writing_LArSoft_service</a>.</p>
<h2 id="files">Files</h2>
<p>The example is split between two directories:</p>
<pre><code>larexamples/Services/AtomicNumber/         ### contains all the service code ###
|-- README                                                          # this file
|-- Providers                                        ## service provider code ##
|   |-- AtomicNumber.h                        # header for the service provider
|   |-- AtomicNumber.cxx                      # source for the service provider
|   `-- atomic_number_standard.fcl          # &quot;standard&quot; service configurations
`-- Services                                    ## art service interface code ##
    |-- AtomicNumberService.h            # header for the art service interface
    `-- AtomicNumberService_service.cc # implementation of art service interface

test/Services/AtomicNumber/                   ### contains the service tests ###
|-- Providers                              ## unit tests for service provider ##
|   |-- AtomicNumber_test.cc         # plain unit test with fixed configuration
|   |-- BoostedAtomicNumber_test.cc     # unit test based on Boost test library
|   |-- ValidateAtomicNumberConfiguration_test.cc   # unit test with validation
|   `-- test_krypton_atomic_number.fcl      # configuration for Boost unit test
`-- Services                           ## unit test for art service interface ##
    |-- AtomicNumberTest_module.cc              # test module using the service
    `-- test_krypton_atomic_number.fcl      # configuration of a test using art</code></pre>
<p>Each directory also has its own <code>CMakeLists.txt</code> file.</p>
<p>LArSoft mildly recommends the following file name suffices:</p>
<ul>
<li><code>.h</code> for all the header files</li>
<li><code>.cc</code> for modules, services and tests; this is because CET build macros prefer the <code>.cc</code> suffix</li>
<li><code>.cxx</code> for algorithm implementation and anything not connected to <em>art</em></li>
</ul>
<p>If adding code to an existing directory, it’s good practise to spend a couple of minutes to observe the name patterns of files in the directory, its parent and its siblings.</p>
<h3 id="directory-structure">Directory structure</h3>
<p>The directory structure is overly detailed for such a small project, but it contains main essential components.</p>
<p>First, the code is divided into two disjoint subtrees that replicate the same internal structure. This is a LArSoft prescription: all the code and TODO point to the wiki prescription configuration files are in <code>larexamples</code> subdirectory, and the tests are under the <code>test</code> subdirectory.</p>
<p>The choice of two sublevels <code>Services</code> and then <code>AtomicNumber</code> is driven by clarity of organisation, and may be too much for your service. It is conceivable that the same directory hosts more than one service (see e.g. <code>lardata/DetectorInfo</code> and <code>lardata/DetectorInfoServices</code>).</p>
<p>Internally, the subdirectory <code>AtomicNumber</code> contains two directories. It is important that the art service interfaces, that are art-dependent, are compiled in separate libraries than the service providers, that have smaller framework dependency. The simplest way to achieve this is to have the two sets in two different directories, as in this example. Alternatively, multiple libraries can be compiled from sources in a single directory by a careful tuning of the <code>CMakeLists.txt</code> file.</p>
<h2 id="the-service-provider-atomicnumber">The service provider: <code>AtomicNumber</code></h2>
<p>The service provider is where all the action goes. In this example, there is not much action ongoing though: the provider just reads a value from the configuration, and it returns it back when asked.</p>
<p>The provider is split in the usual header and implementation file.</p>
<h3 id="cmakelists.txt"><code>CMakeLists.txt</code></h3>
<p>The tasks of this <code>CMakeLists.txt</code> file are:</p>
<ul>
<li>generate a library for the provider</li>
<li>install headers and source code (meaning to make sure they appear in the final UPS product</li>
<li>install FHiCL configuration (as above)</li>
</ul>
<p>The installation part is done by the usual macros (<code>install_XXX()</code>). The generation of the library can happen with either <code>art_make()</code> or <code>art_make_library()</code> macros. They both do very similar things in this case, and they will grab all the source files that end in <code>.cc</code>, <code>.cxx</code> etc. and that do not have a “magic” ending (<code>_module.cc</code>, <code>_service.cc</code>, …), and pull them together into a library that will be called after the path it is created from, which turns into <code>larexamples_Services_AtomicNumber_Providers</code>. We recommend that, although inconvenient, the library name is left this long, since it helps avoiding collisions (<code>Providers</code> is not a good library name):</p>
<ul>
<li>the library file name is <code>liblarexamples_Services_AtomicNumber_Providers.so</code> (in Linux) or <code>.dylib</code> (in Darwin), in <code>$LAREXAMPLES_LIB</code> directory</li>
<li>the name to be used in <code>CMakeLists.txt</code> files including it (as in this service below) is <code>larexamples_Services_AtomicNumber_Providers</code></li>
<li>this name does not appear in the configuration files</li>
</ul>
<p>In this case, we opted for <code>art_make()</code>. Filling the list of libraries can be tricky. A way to address the problem is to give a minimalist first try and then add as needed: the build system settings will tell us loudly if anything is missing. A recipe that gives good results to have a first list is to:</p>
<ol style="list-style-type: decimal">
<li>check all the included headers</li>
<li>add a library for each of them</li>
</ol>
<p>Running the following command from <code>${MRB_SOURCES}/larexamples/larexamples/Services/AtomicNumber/Providers</code> :</p>
<pre><code>grep -h -e &#39;# *include&#39; *</code></pre>
<p>gives the output:</p>
<pre><code>#include &quot;AtomicNumber.h&quot;
#include &quot;art/Utilities/Exception.h&quot;
#include &quot;fhiclcpp/ParameterSet.h&quot;
#include &quot;fhiclcpp/types/Atom.h&quot;
#include &quot;fhiclcpp/types/Table.h&quot;</code></pre>
<p>The first is the library we are building, so we don’t include it. The second header comes from <code>art/Utilities</code>: the library name is contained in a variable in <em>cmake</em> called <code>${ART_UTILITIES}</code>. The next three describe things in the FHiCL C++ library. Following the pattern, we would get two libraryes: <code>${FHICLCPP}</code> and <code>${FHICLCPP_TYPES}</code>. It turns out, FHiCL C++ produces only one library with everything, and that is in <code>${FHICLCPP}</code>. You can peek at the libraries from that UPS product by running</p>
<pre><code>ls &quot;$FHICLCPP_LIB&quot;</code></pre>
<p>In this case, it worked pretty well. The UPS products where this approach typically fails are <em>nutools</em> (where the include path does not even tell you it’s a <em>nutools</em> header), ROOT, CLHEP.</p>
<h3 id="atomicnumber.h"><code>AtomicNumber.h</code></h3>
<p>The design of this service is extremely simple. We allow it to receive configuration from the framework, and we have just one information we provide.</p>
<h4 id="documentation-explanation">Documentation explanation</h4>
<p>The header is documented with Doxygen. The complete documentation goes into the header. This is recommended because headers might be shipped without implementation, and because headers contain all the declarations that callers may use.</p>
<p>We first document the file itself (at the very beginning) to include author name and contact information, and a short description of the content of the file. The date is a <em>creation</em> date and it’s not essential.</p>
<p>The namespace should be documented only if unique, that is not the case here.</p>
<p>The provider class should have documentation for the class itself, for every non-obvious member function, and for <em>all</em> data members. The class documentation includes a detailed description of the configuration parameters, that can be much more verbose than the one by <code>fhicl::Comment</code> (see <a href="#configuration-and-validation">configuration and validation</a> below). Note the use of grouping to collect together methods dealing with the same topic. In this example its use (the “Accessors” group) is quite specious, since there is only one method after all. This construct is used for example in <code>geo::GeometryCore</code> documentation to group methods operating with TPCs, with wire planes, with wires, etc.</p>
<h4 id="namespace">Namespace</h4>
<p>The provider is placed in a namespace that describes its general category. The namespace <code>lar</code> is used for things that are specific of LArSoft mechanics. Services and algorithms rarely fall in it, as there are more appropriate ones like <code>sim</code> (simulation), <code>reco</code> (reconstruction), etc.</p>
<h4 id="configuration-and-validation">Configuration and validation</h4>
<p>The configuration of the provider relies on FHiCL constructs to document and validate it at run time. This infrastructure is described at <a href="https://cdcvs.fnal.gov/redmine/projects/fhicl-cpp/wiki/Configuration_validation_and_fhiclcpp_types" class="uri">https://cdcvs.fnal.gov/redmine/projects/fhicl-cpp/wiki/Configuration_validation_and_fhiclcpp_types</a>. The idea is that the configuration parameters are represented by special data member within a single data structure. In our example this data structure is contained in the provider itself and it’s called <code>Config</code>. All of its one elements have a “comment” concisely describing their purpose (and normally the unit their values are expressed in). The link shows how to create more complex structures than just simple numbers. The provider constructor directly accepts a class of type <code>Config</code>. The only easy way to construct a <code>Config</code> object is via a parameter set. The <em>art</em> framework does that in one way (see <a href="#atomicnumberservice.h">AtomicNumberService.h</a>), and the tests do it in another (see <a href="#validateatomicnumberconfiguration_test.cc">ValidateAtomicNumberConfiguration_test.cc</a> and the other <code>AtomicNumber</code> constructor): the <code>Config</code> constructor is where the two ways finally merge. Note that the provider does not run the validation. The test must invoke validation explicitly, and <em>art</em> framework does the same behind the scenes when constructing the service.</p>
<h4 id="coding-practises">Coding practises</h4>
<p>The ridiculously long include guard <code>LAREXAMPLES_SERVICES_ATOMICNUMBER_PROVIDER_ATOMICNUMBER_H</code> is in fact the recommended one. Having naming collisions for include guards is pretty much guaranteed to yield misleading compilation errors. So we stick the whole file path into it.</p>
<p>There are two constructors. One is the usual one based on FHiCL <code>ParameterSet</code>, the other is a more unusual one directly based on our configuration class. The latter one is intended to be used indirectly and it is exposed for the <em>art</em> service and the tests to be able to enable configuration validation (see also <a href="#configuration-and-validation">Configuration and validation</a> above). The explanation of their existence is better seen in their use, in <a href="#atomicnumber_test.cc">AtomicNumber_test.cc</a>, in <a href="#validateatomicnumberconfiguration_test.cc">ValidateAtomicNumberConfiguration_test.cc</a> and in <a href="#atomicnumberservice.h">AtomicNumberService.h</a>. Keep in mind that the constructor based on a <code>ParameterSet</code> does <em>not</em> use validation. The other one does not either, but it enables the caller to do that.</p>
<p>LArSoft recommends that service providers are not copyable nor movable. Some LArSoft utilities (noticeably, <code>lar::providerFrom()</code> function) will refuse to work otherwise. A set of deleted constructors and assignment operators fulfils this requirement.</p>
<p>We also insist that the data members be private. This complicates the interface because of the need of “accessors” (like the <code>Z()</code> method here) but improve maintainability, allowing changes in the underneath representation being absorbed by the implementation of the interface, that can stay unchanged (for example, imagine replacing a C array data member with a <code>std::vector</code> or <code>std::array</code>).</p>
<p>The choice of a data member name ending with an underscore character (<code>Z_</code>) is not a recommendation, but just one of the possible solutions. It <em>is</em> recommended that the names for the interface methods have clear meaning, internally consistent style, and then briefness: e.g., avoid having <code>atomic_number()</code> and <code>nucleonNumber()</code> together. Remember that especially for a service once the names are set the whole community will have to live with them.</p>
<h3 id="atomicnumber.cxx"><code>AtomicNumber.cxx</code></h3>
<p>In this example, the implementation file is completely trivial. Its mere presence, though, has the effect that a library is generated for <code>AtomicNumber</code>. You will rarely find yourself in a situation where the implementation file is not necessary, and we suggest that also in such case you add a trivial one nonetheless.</p>
<h3 id="atomic_number_standard.fcl"><code>atomic_number_standard.fcl</code></h3>
<p>With the service provider, it’s a good idea to provide also some example configuration that reflects the most common use case (or cases). The FHiCL file provided here can be used to configure both the provider and the art service. It contains the configurations in a “prolog”, that is a special section that contains pieces of configuration that can be reused in the main configuration. An example of how is in the test configuration <code>test_krypton_atomic_number.fcl</code> (see below). It also contains a fair amount of comments, describing what is inside the file itself. It would also include a list of “dependencies”, mainly a list of services this provider depends on: nothing in this example, but check for other examples that do have this kind of dependency.</p>
<p>This configuration file must be present in the final UPS product. This is achieved by the <code>install_fhicl()</code> macro in <code>CMakeLists.txt</code> in <code>Providers</code> directory.</p>
<h2 id="the-service-atomicnumberservice">The service: <code>AtomicNumberService</code></h2>
<p>The <em>art</em> service is extremely simple in this example: it does not need to react to framework state changes (like the opening of a new input file or event), and it does not implement an abstract interface (that is, there is only one possible implementation for this service). The only tasks of this service are:</p>
<ul>
<li>manage and provide the service provider, <code>AtomicNumber</code></li>
<li>implement the (terse) service interface that <em>art</em> requires</li>
<li>implement the (even terser) interface that LArSoft recommends</li>
</ul>
<p>It is placed in a separate directory to have dependencies independent from the ones of the provider (see <a href="#directory-structure">Directory structure</a> above for an explanation).</p>
<h3 id="atomicnumberservice.h">AtomicNumberService.h</h3>
<p>The header has two main components: the declaration of the service class and the declaration of the <em>art</em> service macros.</p>
<p>For the first part we use a template that LArSoft providers to create the simplest <em>art</em> service possible, that can only return its provider. This template imposes requirements on the provider, that are documented with the template itself.</p>
<p>The second part is required by <em>art</em>, that is in this way informed of the existence of this class as a service.</p>
<p>The only interesting part here are names: we encourage the <em>art</em> service to live in the same name as the service provider. Also, we recommend to have the names of service and provider be easy to match: LArSoft uses often a (meaningful) name for the provider, and the same name with “Service” appended for the <em>art</em> service. Other times, the provider is appended a “Provider” suffix too; this is usually to avoid name conflicts with existing classes.</p>
<p>Note that basically no documentation is provided. The provider documents all the information specific to the service.</p>
<h3 id="atomicnumberservice_service.cc"><code>AtomicNumberService_service.cc</code></h3>
<p>The implementation file is required as it needs to contain the <em>art</em> service definition macro call. The (already small) implementation of the service class itself is included in the template itself, and no customisation is required here.</p>
<h2 id="tests">Tests</h2>
<p>The purpose of these “unit” tests is to exercise all the features of the service provider and its <em>art</em> interface. We have two groups of tests. The first group exercises the provider only, and it does not depend on the framework. The second one exercises the functions that are specific to the <em>art</em> service interface, and does not necessarily tests the features that were tested also by the provider. An even better pattern is to have a test that can be run in both modes – one of <code>geo::GeometryCore</code> tests is such: it has a test library and both the provider and the service tests call it. The following tests are implemented:</p>
<ul>
<li><code>AtomicNumber_test</code>: provider unit test with no configuration</li>
<li><code>BoostedAtomicNumber_test</code>: provider unit test that uses Boost unit test, configured via FHiCL file</li>
<li><code>ValidateAtomicNumberConfiguration_test</code>: provider unit test using configuration presentation and validation</li>
<li><code>AtomicNumberTest_module</code>: service unit test</li>
</ul>
<p>When <code>mrb test</code> is used, all the tests are run automatically and all failures are individually reported. A global output log is also available somewhere, typically in <code>${MRB_BUILDDIR}/Testing/Temporary/LastTest.log</code>.</p>
<h3 id="cmakelists.txt-1">CMakeLists.txt</h3>
<p>Tests are declared to <code>cmake</code> via the <code>cet_test()</code> macro. This macro can compile the test libraries and executable, run the test, verify the output and report errors. Some of these features are only rarely used.</p>
<p>In case of a stand-alone unit test, it’s usually enough specify a test name (mandatory), source files to be compiled into the test executable, and a list of libraries to link with it. In our examples we did not specify the source files, which are therefore guessed by <code>cet_test()</code> by adding <code>.cc</code> to the test name: for example, in <code>AtomicNumber_test</code>, the source will be expected to be in <code>AtomicNumber_test.cc</code>. In <code>BoostedAtomicNumber_test</code>,we added a command line argument with <code>TEST_ARGS</code> and we also specified that that file needs to be copied in the test directory with <code>DATAFILES</code>. We rely on <code>cet_test()</code> to link the proper Boost libraries to enable unit testing, by <code>USE_BOOST_UNIT</code> flag.</p>
<p>For the <em>art</em> service test, we run a full <code>lar</code> job: we specify that the executable name is special, <code>lar</code>, with <code>TEST_EXEC</code>, and we also tell <code>cet_test()</code> that it should not bother to try and build it: it’s <code>HANDBUILT</code> already. We add the <em>lar</em> option <code>--rethrow-all</code> that should prevent <em>art</em> from absorbing, dealing with and eventually hiding exceptions: if an exception occurs and reaches <em>art</em>, it will not try to handle it. The job requires a test module. To build its library we use the usual <code>simple_plugin()</code> macro, that is not specific for testing. It’s worth noting that the this list of libraries is the only one including <em>art</em>: the provider tests do not depend on it.</p>
<h3 id="atomicnumber_test.cc">AtomicNumber_test.cc</h3>
<p>This test uses hard-coded configurations. This is an approach complementary to using user-supplied configurations: it allows to test with total predictability of results, but it does not necessarily test real use cases. The <code>BoostedAtomicNumber_test</code> test takes the alternative approach.</p>
<p>The general pattern of this test is to have a test function that accepts a configuration and the expected test results, performs the test and verifies the results. This function is called here twice, to test the default configuration and a custom one. The test is a common executable with a <code>main()</code> function that runs the tests and returns an exit code. Failing tests have to return a non-zero exit code, in the UNIX tradition. We chose here to return, in fact, the number of errors encountered. Note that exit codes can be 8 bit signed integers, that don’t accommodate for large values.</p>
<p>The actual test function, <code>TestConfiguration()</code>, illustrates the use of a somehow cryptic facility, the <code>TesterEnvironment</code> class. The gain in using it is that it takes care of:</p>
<ul>
<li>parsing a FHiCL file (if provided, which we don’t here)</li>
<li>initializing the message facility service</li>
<li>keeping track of all service configurations (and test algorithm configuration too: another facility we don’y use here)</li>
</ul>
<p>This facility can be extended to set up, manage and provide other service providers too, which makes it a small test framework in his own. But we don’t do that here either.</p>
<p>The test environment is a template that requires a configuration object. The configuration object holds information about the configuration: a bunch of strings representing names of services, configuration file paths, and actual FHiCL configuration. The test environment is initialised with one of these objects and will use its information.</p>
<p>We first initialise the configuration object, giving it a test name (mostly eye candy) and we inform it of which configuration string is associated to a service called <code>&quot;AtomicNumberService&quot;</code>. This is now just a label, but it matches the label that would be used in a full <em>art</em>-aware configuration file. Then we create a <code>TesterEnvironment</code> object with this configuration. There are many ways to do that; in this example we take the simplest one of using a function that does just that, given the configuration as first argument.</p>
<p>We create a new service provider <code>AtomicNumber Zprov</code> using the constructor that takes a <code>fhicl::ParameterSet</code> as a argument. We obtain the parameter set from the test environment, asking it about the same label we just set. In the while, it converted the configuration <em>string</em> we gave it into a <em>parameter set</em>.</p>
<p>The test itself is fairly trivial. We call the member function <code>Z()</code> and if the result is unexpected, we write an error message and increase an error count.</p>
<p>In the end, the error count is returned. The <code>main()</code> functions will sum all the error counts and exit with that as the exit code, and the system running the test will know whether it was successful (exit code 0) or not.</p>
<h3 id="boostedatomicnumber_test.cc">BoostedAtomicNumber_test.cc</h3>
<p>This test is similar to <code>AtomicNumber_test</code>, differing in two important aspects:</p>
<ul>
<li>it requires a configuration file from command line</li>
<li>it is implemented with Boost unit test suite</li>
</ul>
<p>The configuration file is required to have a section configuring <code>AtomicNumber</code> provider as it were in a <em>art</em> job, via <code>AtomicNumberService</code> parameter set, and also have the expected results expressed in a<code>physics.analyzers.expected</code> parameter set, in a configuration equivalent to a <em>art</em> job with an analyser module instance called <code>expected</code>. The test expects this parameter set to have the same structure as the service provider configuration. Such a FHiCL configuration file is provided: <code>test_krypton_atomic_number.fcl</code>.</p>
<p>Note that the requirement on the configuration file are documented at top of the test source, in the customary Doxygen format.</p>
<h4 id="running-a-boost-test">Running a Boost test</h4>
<p>A Boost unit test executable supports a large number of options. Among the most useful: <code>--report_level=detailed</code> will give a precise report of what went well and what went wrong in the test; <code>--log_level=all</code> will print all the checks on screen. For example: <sub><sub><sub><sub> “<span class="math inline">${MRB_BUILDDIR}/larexamples/bin/BoostedAtomicNumber_test&quot; --log_level=all \
 &quot;$</span>{MRB_SOURCE}/larexamples/test/Services/AtomicNumber/Providers/test_krypton_atomic_number.fcl” </sub></sub></sub></sub></p>
<h4 id="boost-unit-test-library">Boost unit test library</h4>
<p>The Boost unit test suite is made of C preprocessor macros that make the code look like invalid C++ and make error messages nearly unusable. It provides a good deal of facilities to automate the most common test tasks and reduce the amount of typing. The implementation we use here uses a <em>fixture</em>. A fixture is a class that provides an environment in which the tests run. The tests in the <code>BOOST_AUTO_TEST_CASE()</code> blocks are aware of the content of the fixture. In fact, they see all the public members of the fixture class directly (they constitute member functions of a class derived by the fixture class, created automatically by Boost). We use our own class <code>AtomicNumberTextFixture</code> as a fixture, that has among its public data members an instance of <code>AtomicNumber</code> provider called <code>Zprov</code>. Therefore, our tests in <code>BOOST_AUTO_TEST_CASE()</code> will be able to access it directly, for example writing <code>auto Z = Zprov.Z();</code>.</p>
<h4 id="the-custom-fixture-class">The custom fixture class</h4>
<p>Our fixture class can be seen as made of two parts:</p>
<ol style="list-style-type: decimal">
<li>general test environment including configuration handling</li>
<li>an instance of our provider</li>
</ol>
<p>The fixture class <em>derives</em> from a test environment, that is very similar to <code>TesterEnvironment</code> class used in <code>AtomicNumber_test</code>. The difference is that the configuration object is not <code>testing::BasicEnvironmentConfiguration</code>, but a class derived from it, <code>testing::BoostCommandLineConfiguration</code>, that adds the ability of automatically read the configuration file from command line. Here tricks are needed because we don’t create the fixture object explicitly, but rather have Boost take care of that. Boost will use the default constructor, so we must be sure that our fixture constructs exactly as we want on the spot, since after the construction e are not given a chance to fix, tune or adjust it. The <code>testing::BasicEnvironmentConfiguration</code> and <code>testing::TesterEnvironment</code> classes take care of all those tricks. Still we need additional data members (for example, we need an instance of the service provider <code>AtomicNumber</code>), so we have to derive our fixture from <code>testing::TesterEnvironment</code> instead of using it directly.</p>
<p>The instance of service provider is held as data member, and initialised in the default constructor in the same way as in <code>AtomicNumber_test</code>, calling the constructor with a parameter set. Here the parameter set is obtained by the fixture class itself, that derives from <code>testing::TesterEnvironment</code>.</p>
<p>We also save the set of values describing the expected results, that comes from the configuration file with the label <code>&quot;expected&quot;</code>. <code>TesterParameters()</code> method assumes that there are test analyser modules, configured in <code>physics.analyzers</code> as per <em>art</em> rules.</p>
<h4 id="the-test-cases">The test cases</h4>
<p>The test starts with the declaration of which fixture class we use, and a name for the test: <code>BOOST_FIXTURE_TEST_SUITE()</code>. This is matched by the declaration that the test is over: <code>BOOST_AUTO_TEST_SUITE_END()</code>. You can imagine the call <code>BOOST_FIXTURE_TEST_SUITE(BoostedAtomicNumberTest, AtomicNumberTestFixture)</code> to be equivalent to a line <code>class BoostedAtomicNumberTest: public AtomicNumberTestFixture {</code>, and the closing <code>BOOST_AUTO_TEST_SUITE_END()</code> equivalent to a <code>};</code>: everything in between these belongs to the <code>BoostedAtomicNumberTest</code> test class. The test case <code>BOOST_AUTO_TEST_CASE(AllTests)</code> macro call might be method definitions, like <code>void AllTests()</code>. Boost unit test suite will know what to do with this class and its methods.</p>
<p>The only test case we have performs the same test as <code>AtomicNumber_test</code>. First, we extract from <code>physics.analyzers.expected.Z</code> the value we expect for Z, and then we verify that <code>AtomicNumber::Z()</code> returns that very same value. To do that we use a <code>BOOST_CHECK_EQUAL()</code> macro that will take care of communicating errors in a way that depends on the test arguments.</p>
<h3 id="validateatomicnumberconfiguration_test.cc">ValidateAtomicNumberConfiguration_test.cc</h3>
<p>This test just checks that the given service configuration is valid. It relies on the validation feature of FHiCL library and on the fact that the provider supports configuration via objects based on <code>fhicl::Atom</code>, <code>fhicl::Table</code> and the such (<code>AtomicNumber::Config</code>).</p>
<p>As usual, the instructions for running the test are described in words in the documentation of the source file.</p>
<p>The test is made of three part: configuration of the test environment, printing the allowed provider configuration on screen, and checking the provider configuration from the file specified on the command line.</p>
<h4 id="testing-environment">Testing environment</h4>
<p>The test environment here is similar to the one in <code>AtomicNumber_test</code>, with two differences.</p>
<p>The first difference is that the configuration file path is read from the command line. The configuration object is created with knowledge of the command line arguments (<code>argc</code> and <code>argv</code>), which it will use to extract the path.</p>
<p>The second difference is that we don’t provide a default configuration. We don’t need to, since we expect the configuration from command line. But this means that if no configuration file is specified, we do not have any fallback configuration and the test will immediately fail.</p>
<h4 id="printing-the-allowed-configuration">Printing the allowed configuration</h4>
<p>An object of type <code>fhicl::Table</code> is able to print the configuration it represents. All we have to do is to create such a table with provider’s <code>Config</code> as content. Such an object is useful enough that <code>AtomicNumber</code> provider has a name for it, <code>parameters_type</code>. A technical detail is that to create such a table we need to give either a parameter set or a name. Neither of them is important, so we choose the fastest way, just provide a name. Then it’s only matter of calling its <code>print_allowed_configuration()</code> method.</p>
<h4 id="testing-the-validity-of-the-configuration">Testing the validity of the configuration</h4>
<p>The other thing an object of type <code>fhicl::Table</code> can do is to validate a FHiCL parameter set. We provide this method a parameter set and a list of keys that should be ignored, and the method <code>validate_ParameterSet()</code> checks that:</p>
<ul>
<li>all the elements of the wrapped <code>Config</code> object that have no default value are present in the specified parameter set</li>
<li>that no key in the parameter set is present that does not match any element in the wrapped <code>Config</code> object, with the possible exception of the ignored keys</li>
</ul>
<p>If any of these checks fails, an exception is thrown. In the test, we have asked to ignore a key called <code>&quot;service_type&quot;</code>. This key is by default added by <em>art</em> and some configuration files end up having it (for example, configuration files derived from the dump of a <em>art</em>-processed configuration, as with <code>config_dumper</code> or the <code>--debug-config</code> option of <code>art</code>). With this, any valid <em>art</em> configuration file including the service <code>AtomicNumberService</code> is expected to pass this test.</p>
<h3 id="atomicnumbertest_module.cc">AtomicNumberTest_module.cc</h3>
<p>A test for an <em>art</em> service requires running <code>lar</code> with the proper configuration file, possibly including one or more test modules.</p>
<p>The configuration file, called <code>test_krypton_atomic_number.fcl</code>, that is in fact based on its namesake in the <code>Providers</code> test directory, but dressed to work with <em>art</em>: it adds a test module <code>&quot;atomicnumbertest&quot;</code> of type <code>AtomicNumberTest</code>.</p>
<p>In this example, the <em>art</em> service does not add any functionality on top of the provider, so only the trivial test <code>AtomicNumberTest</code> is provided. It obtains the service provider from the framework (testing that <code>lar::providerFrom()</code> works with our service), and exercises the provider one-method interface. The test is performed in the <code>beginJob()</code> method: at that time, services are already available but no input file is open. In this way, no input file is actually needed for the test to run — and in fact we don’t provide any.</p>
<p>The validation of the configuration, that for the provider was explicitly checked only in <code>ValidateAtomicNumberConfiguration_test</code>, is automatically performed by <em>art</em>, both in this test and every time the service is instantiated in a regular run.</p>
<h2 id="questions">Questions?</h2>
<p>If you have any question about the example, please contact its author. This section will be populated with questions and their answers.</p>
</body>
</html>
